{"version":3,"sources":["App.js","index.js","raw_pride.svg"],"names":["App","_ref","count","size","gravity","spread","decay","_useState","useState","_useState2","Object","slicedToArray","circles","setCircles","_useState3","_useState4","screenClicked","setScreenClicked","_useState5","x","y","_useState6","mousePos","setMousePos","style","position","userSelect","fontWeight","borderRadius","handleClick","e","click","touches","clientX","clientY","rgbValue","offset","unixTime","Date","now","Math","abs","sin","floor","useEffect","event","window","addEventListener","removeEventListener","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","newCircles","filter","circle","r","map","random","c","i","push","g","b","react_default","a","createElement","Fragment","index","key","objectSpread","top","left","fontSize","color","ReactDOM","render","src_App","src","pride","alt","document","getElementById","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.4439099a.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from \"react\";\n\nfunction App({ count, size, gravity, spread, decay }) {\n  const [circles, setCircles] = useState([]);\n  const [screenClicked, setScreenClicked] = useState(false);\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n\n  const style = {\n    position: \"fixed\",\n    userSelect: \"none\",\n    fontWeight: \"bolder\",\n    borderRadius: \"100%\"\n  };\n\n  const animate = () => {\n    const newCircles = circles\n      .filter(circle => circle.r >= 0)\n      .map(circle => {\n        return {\n          x: circle.x + decay / 2 + 1 - Math.random() * 2,\n          y: circle.y + decay / 2 + gravity,\n          r: circle.r - decay,\n          c: circle.c\n        };\n      });\n\n    if (screenClicked) {\n      for (let i = 0; i < count; i++) {\n        newCircles.push({\n          x: mousePos.x - spread / 2 + Math.random() * spread,\n          y: mousePos.y - spread / 2 + Math.random() * spread,\n          r: size,\n          c: { r: rgbValue(0), g: rgbValue(1 / 3), b: rgbValue(2 / 3) }\n        });\n      }\n      setScreenClicked(false);\n    }\n    setCircles(newCircles);\n  };\n\n  const handleClick = e => {\n    const click = e.touches ? e.touches[0] : e;\n    setMousePos({ x: click.clientX, y: click.clientY });\n    setScreenClicked(true);\n  };\n\n  const rgbValue = offset => {\n    const unixTime = Date.now() / 1000;\n    const y0 = 75,\n      y1 = 230,\n      x0 = 0,\n      x1 = 1,\n      x = Math.abs(Math.sin(unixTime / 10 + unixTime * offset));\n\n    return Math.floor((y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0));\n  };\n\n  useEffect(() => {\n    const event = \"ontouchstart\" in window ? \"touchstart\" : \"mousedown\";\n    window.addEventListener(event, handleClick);\n    return () => {\n      window.removeEventListener(event, handleClick);\n    };\n  }, []);\n\n  useInterval(animate, 75);\n\n  return (\n    <>\n      {circles.map((circle, index) => (\n        <div\n          key={index}\n          style={{\n            ...style,\n            top: circle.y,\n            left: circle.x,\n            fontSize: circle.r + \"px\",\n            color:\n              \"rgba(\" +\n              circle.c.r +\n              \", \" +\n              circle.c.g +\n              \", \" +\n              circle.c.b +\n              \", 1)\"\n          }}\n        >\n          +\n        </div>\n      ))}\n    </>\n  );\n}\n\n/**\n * Custom Hook to execute a callback every given interval.\n */\nfunction useInterval(callback, delay) {\n  /**\n   * Stores the callback in a ref to allow persistance between renders.\n   */\n  const savedCallback = useRef();\n\n  /**\n   * Set the callack ref to callback function of each render.\n   *\n   * The callback function will be redefined each render,\n   * but we have captured the callback when this component mounts.\n   */\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  /**\n   * Call the function every interval.\n   *\n   * Restart the interval if the delay value changes.\n   *\n   * If the component unmounts, cleanup the interval.\n   */\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport pride from \"./raw_pride.svg\";\n\nReactDOM.render(\n  <>\n    <App count={8} size={16} gravity={2.5} spread={25} decay={0.4} />\n    <button>Click For Glitter</button>\n    <img src={pride} alt=\"pride logo\" />\n  </>,\n  document.getElementById(\"root\")\n);\n","module.exports = __webpack_public_path__ + \"static/media/raw_pride.f30091c7.svg\";"],"sourceRoot":""}