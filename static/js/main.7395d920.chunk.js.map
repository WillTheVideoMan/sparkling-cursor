{"version":3,"sources":["GlitterParticles.js","index.js","raw_pride.svg"],"names":["GlitterOverlay","_ref","count","size","gravity","spread","decay","_useState","useState","_useState2","Object","slicedToArray","particles","setParticles","_useState3","_useState4","screenInput","setScreenInput","handleClick","e","input","touches","x","clientX","y","clientY","rgbValue","offset","unixTime","Date","now","Math","abs","sin","floor","useEffect","eventType","window","addEventListener","removeEventListener","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","nextParticles","filter","particle","r","map","random","c","i","push","g","b","length","index","react_default","a","createElement","key","style","position","zIndex","userSelect","fontWeight","top","left","fontSize","color","ReactDOM","render","Fragment","GlitterParticles","src","pride","alt","document","getElementById","module","exports","__webpack_require__","p"],"mappings":"2IA+LeA,EAnLQ,SAAAC,GAA6C,IAA1CC,EAA0CD,EAA1CC,MAAOC,EAAmCF,EAAnCE,KAAMC,EAA6BH,EAA7BG,QAASC,EAAoBJ,EAApBI,OAAQC,EAAYL,EAAZK,MAAYC,EAIhCC,mBAAS,IAJuBC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GAI3DK,EAJ2DH,EAAA,GAIhDI,EAJgDJ,EAAA,GAAAK,EAS5BN,qBAT4BO,EAAAL,OAAAC,EAAA,EAAAD,CAAAI,EAAA,GAS3DE,EAT2DD,EAAA,GAS9CE,EAT8CF,EAAA,GAgB5DG,EAAc,SAAAC,GAOlB,IAAMC,EAAQD,EAAEE,QAAUF,EAAEE,QAAQ,GAAKF,EAKzCF,EAAe,CAAEK,EAAGF,EAAMG,QAASC,EAAGJ,EAAMK,WAQxCC,EAAW,SAAAC,GAIf,IAAMC,EAAWC,KAAKC,MAAQ,IAa5BR,EAAIS,KAAKC,IAAID,KAAKE,IAAIL,EAAW,GAAKA,EAAWD,IAKnD,OAAOI,KAAKG,OATD,IAGJ,EAMuBZ,GARvB,KAQkCA,EAPlC,IAOW,IAuFpB,OA7BAa,oBAAU,WAOR,IAAMC,EAAY,iBAAkBC,OAAS,aAAe,YAM5D,OALAA,OAAOC,iBAAiBF,EAAWlB,GAK5B,WACLmB,OAAOE,oBAAoBH,EAAWlB,KAEvC,IAoDL,SAAqBsB,EAAUC,GAI7B,IAAMC,EAAgBC,mBAQtBR,oBAAU,WACRO,EAAcE,QAAUJ,IAU1BL,oBAAU,WASR,GAAc,OAAVM,EAAgB,CAClB,IAAII,EAAKC,YATX,WACEJ,EAAcE,WAQaH,GAC3B,OAAO,kBAAMM,cAAcF,MAE5B,CAACJ,IAlFJO,CA1EgB,WAQd,IAAMC,EAAgBrC,EACnBsC,OAAO,SAAAC,GAAQ,OAAIA,EAASC,GAAK,IACjCC,IAAI,SAAAF,GACH,MAAO,CACL7B,EAAG6B,EAAS7B,EAAIhB,EAAQ,EAAI,EAAoB,EAAhByB,KAAKuB,SACrC9B,EAAG2B,EAAS3B,EAAIlB,EAAQ,EAAIF,EAC5BgD,EAAGD,EAASC,EAAI9C,EAChBiD,EAAGJ,EAASI,KAYlB,GAAIvC,EAAa,CACf,IAAK,IAAIwC,EAAI,EAAGA,EAAItD,EAAOsD,IACzBP,EAAcQ,KAAK,CACjBnC,EAAGN,EAAYM,EAAIjB,EAAS,EAAI0B,KAAKuB,SAAWjD,EAChDmB,EAAGR,EAAYQ,EAAInB,EAAS,EAAI0B,KAAKuB,SAAWjD,EAChD+C,EAAGjD,EACHoD,EAAG,CAAEH,EAAG1B,EAAS,GAAIgC,EAAGhC,EAAS,EAAI,GAAIiC,EAAGjC,EAAS,EAAI,MAO7DT,EAAe,MAMjBJ,EAAaoC,IA4BMrC,EAAUgD,OAAS,GAAK5C,EAAc,GAAK,MAOzDJ,EAAUyC,IAAI,SAACF,EAAUU,GAAX,OACnBC,EAAAC,EAAAC,cAAA,OACEC,IAAKJ,EACLK,MAAO,CACLC,SAAU,QACVC,OAAQ,KACRC,WAAY,OACZC,WAAY,SACZC,IAAKpB,EAAS3B,EACdgD,KAAMrB,EAAS7B,EACfmD,SAAUtB,EAASC,EAAI,KACvBsB,MACE,QACAvB,EAASI,EAAEH,EACX,KACAD,EAASI,EAAEG,EACX,KACAP,EAASI,EAAEI,EACX,SAjBN,4BCjJJgB,IAASC,OACPd,EAAAC,EAAAC,cAAAF,EAAAC,EAAAc,SAAA,KACEf,EAAAC,EAAAC,cAACc,EAAD,CAAK5E,MAAO,EAAGC,KAAM,GAAIC,QAAS,EAAGC,OAAQ,GAAIC,MAAO,MACxDwD,EAAAC,EAAAC,cAAA,OAAKe,IAAKC,IAAOC,IAAI,gBAEvBC,SAASC,eAAe,4BClB1BC,EAAAC,QAAiBC,EAAAC,EAAuB","file":"static/js/main.7395d920.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from \"react\";\nimport PropTypes from \"prop-types\";\n\n/**\n * GlitterOverlay.js - Displays a burst of glitter wherever a user clicks/taps on screen.\n *\n * @param {integer} count - Defines the number of  particles per click/tap.\n * @param {integer} size - Defines the size of each  particle.\n * @param {integer} gravity - Defines how quickly the  falls.\n * @param {integer} spread - Defines how much the  spreads about the click/tap locus.\n * @param {integer} decay - Defines how quickly the  particles shrink in size.\n */\nconst GlitterOverlay = ({ count, size, gravity, spread, decay }) => {\n  /**\n   * An array of glitter particles.\n   */\n  const [particles, setParticles] = useState([]);\n\n  /**\n   * Holds the x and y coordinates of any screen input (click or tap) recorded during one animation cycle.\n   */\n  const [screenInput, setScreenInput] = useState();\n\n  /**\n   * Handles a click or tap event by setting relevant state variables.\n   *\n   * @param {object} e - the click or tap event.\n   */\n  const handleClick = e => {\n    /**\n     * If the event has touches accociated with it, then the input was a tap (TouchEvent) rather than a click (MouseEvent).\n     * Hence, set the input to reference the first touch made with the screen.\n     *\n     * Else, set the input to reference the entire event (e), as a mouse event has no touches.\n     */\n    const input = e.touches ? e.touches[0] : e;\n\n    /**\n     * Set the new input position, which will cause a glitter burst to happen at this location.\n     */\n    setScreenInput({ x: input.clientX, y: input.clientY });\n  };\n\n  /**\n   * Returns an RGB value for either R, G or B, based on the time and an optional time offset value.\n   *\n   * @param {integer} offset - A value representing the RGB offset from the current time.\n   */\n  const rgbValue = offset => {\n    /**\n     * Holds the current unix time in seconds.\n     */\n    const unixTime = Date.now() / 1000;\n\n    /**\n     * Define the interpolation parameters. Here, we are taking a sine value between 0 and 1 and mapping it\n     * between an upper (y1) and lower (y0) RGB value.\n     *\n     * By using a sine wave based on time as an interpolant, we can get a smooth cycling through all the colours,\n     * based on time.\n     */\n    const y0 = 75,\n      y1 = 230,\n      x0 = 0,\n      x1 = 1,\n      x = Math.abs(Math.sin(unixTime / 10 + unixTime * offset));\n\n    /**\n     * Return a rounded value of the interpolation between sine curve and RGB value.\n     */\n    return Math.floor((y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0));\n  };\n\n  /**\n   * Main animation loop.\n   */\n  const animate = () => {\n    /**\n     * Define the next particles to be painted, by filtering out particles that have shrunk below\n     * a zero radius (fully decayed) and by mapping the transformation parameters onto each particle.\n     *\n     * Note, x and y coordinated are altered by half the decay size to ensure the particles have no net\n     * drift across the screen.\n     */\n    const nextParticles = particles\n      .filter(particle => particle.r >= 0)\n      .map(particle => {\n        return {\n          x: particle.x + decay / 2 + 1 - Math.random() * 2,\n          y: particle.y + decay / 2 + gravity,\n          r: particle.r - decay,\n          c: particle.c\n        };\n      });\n\n    /**\n     * If the screen has been clicked, we need to add a particle burst onto the particle array.\n     *\n     * For the number of specified particles as defined by props, push a particle onto the next particles array,\n     * applying the correct random spread as defined by props.\n     *\n     * The colour is determined by a cycling rgb function.\n     */\n    if (screenInput) {\n      for (let i = 0; i < count; i++) {\n        nextParticles.push({\n          x: screenInput.x - spread / 2 + Math.random() * spread,\n          y: screenInput.y - spread / 2 + Math.random() * spread,\n          r: size,\n          c: { r: rgbValue(0), g: rgbValue(1 / 3), b: rgbValue(2 / 3) }\n        });\n      }\n\n      /**\n       * Now that the particles have been added, set clicked back to null for the next animation cycle.\n       */\n      setScreenInput(null);\n    }\n\n    /**\n     * Update the glitter particles held in state.\n     */\n    setParticles(nextParticles);\n  };\n\n  /**\n   * Set window event listeners. Only run on first render.\n   */\n  useEffect(() => {\n    /**\n     * Define event listeners based on the device's window properties.\n     *\n     * If the ontouchstart property if present, it means we are using a touch device, and hence\n     * should listen to touch events instead of mouse events.\n     */\n    const eventType = \"ontouchstart\" in window ? \"touchstart\" : \"mousedown\";\n    window.addEventListener(eventType, handleClick);\n\n    /**\n     * On unmount, clean-up the event listener.\n     */\n    return () => {\n      window.removeEventListener(eventType, handleClick);\n    };\n  }, []);\n\n  /**\n   * Animate the glitter particles every 66ms, but only if there are particles to animate or if the screen\n   * has recently received an input.\n   */\n  useInterval(animate, particles.length > 0 || screenInput ? 66 : null);\n\n  /**\n   * Return all the particles with their calculated positions, colours and scales.\n   *\n   * A particle is simply an inline-styled (to keep this overlay self-contained) '+' character.\n   */\n  return particles.map((particle, index) => (\n    <div\n      key={index}\n      style={{\n        position: \"fixed\",\n        zIndex: \"99\",\n        userSelect: \"none\",\n        fontWeight: \"bolder\",\n        top: particle.y,\n        left: particle.x,\n        fontSize: particle.r + \"px\",\n        color:\n          \"rgba(\" +\n          particle.c.r +\n          \", \" +\n          particle.c.g +\n          \", \" +\n          particle.c.b +\n          \", 1)\"\n      }}\n    >\n      +\n    </div>\n  ));\n};\n\nGlitterOverlay.propTypes = {\n  count: PropTypes.number.isRequired,\n  size: PropTypes.number.isRequired,\n  gravity: PropTypes.number.isRequired,\n  spread: PropTypes.number.isRequired,\n  decay: PropTypes.number.isRequired\n};\n\nexport default GlitterOverlay;\n\n/**\n * Custom Hook to execute a callback every given interval.\n */\nfunction useInterval(callback, delay) {\n  /**\n   * Stores the callback in a ref to allow persistance between renders.\n   */\n  const savedCallback = useRef();\n\n  /**\n   * Set the callack ref to callback function of each render.\n   *\n   * The callback function will be redefined each render,\n   * but we have captured the callback when this component mounts.\n   */\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  /**\n   * Call the function every interval.\n   *\n   * Restart the interval if the delay value changes.\n   *\n   * If the component unmounts, cleanup the interval.\n   */\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n\n    /**\n     * If there is no delay, then don't set an interval.\n     * Else, set an interval based on delay.\n     */\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./GlitterParticles\";\nimport pride from \"./raw_pride.svg\";\n\n/**\n * Recommended settings:\n *  count: 8,\n *  size: 16,\n *  gravity: 3,\n *  spread: 25,\n *  decay: 0.25\n */\nReactDOM.render(\n  <>\n    <App count={8} size={16} gravity={3} spread={25} decay={0.25} />\n    <img src={pride} alt=\"pride logo\" />\n  </>,\n  document.getElementById(\"root\")\n);\n","module.exports = __webpack_public_path__ + \"static/media/raw_pride.f30091c7.svg\";"],"sourceRoot":""}